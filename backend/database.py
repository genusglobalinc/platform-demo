import boto3
from boto3.dynamodb.conditions import Key, Attr
from botocore.exceptions import ClientError
from datetime import datetime
import uuid
from typing import Union, Optional, List, Dict
import logging
from backend.utils.security import hash_password

# DynamoDB setup
dynamodb = boto3.resource('dynamodb', region_name='us-east-2')
users_table = dynamodb.Table('Users')
posts_table = dynamodb.Table('Posts')
events_table = dynamodb.Table('Events')

logging.basicConfig(level=logging.DEBUG)

def save_to_dynamodb(item: dict, table_name: str):
    """Generic function to save an item to a DynamoDB table."""
    table = dynamodb.Table(table_name)
    try:
        response = table.put_item(Item=item)
        logging.debug(f"Saved item to {table_name}: {item}")
        return response
    except ClientError as e:
        logging.error(f"Error saving to {table_name}: {e}")
        return None

def create_user_in_db(user_data: dict) -> Optional[str]:
    """Create a new user in the Users table."""
    user_id = str(uuid.uuid4())
    item = {
        "user_id": user_id,
        "username": user_data["username"],
        "email": user_data["email"],
        "password": hash_password(user_data["password"]),
        "is_verified": user_data.get("is_verified", False),
        "created_at": str(datetime.utcnow())
    }
    try:
        users_table.put_item(Item=item)
        logging.debug(f"Created user: {item}")
        return user_id
    except ClientError as e:
        logging.error(f"User creation failed: {e}")
        return None

def get_user_from_db(user_id: str) -> Optional[dict]:
    """Retrieve a user by user_id from the Users table."""
    try:
        response = users_table.get_item(Key={'user_id': user_id})
        return response.get('Item')
    except ClientError as e:
        logging.error(f"Get user failed: {e}")
        return None

def get_user_by_email(email: str) -> Optional[dict]:
    """Retrieve a user by email from the Users table."""
    try:
        response = users_table.get_item(Key={'email': email})
        return response.get('Item')
    except ClientError as e:
        logging.error(f"Get user by email failed: {e}")
        return None

def get_user_by_username(username: str) -> Optional[dict]:
    """Retrieve a user by username using a scan operation (not efficient for large tables)."""
    try:
        response = users_table.scan(FilterExpression=Attr('username').eq(username))
        items = response.get('Items', [])
        return items[0] if items else None
    except ClientError as e:
        logging.error(f"Get user by username failed: {e}")
        return None

def update_user_verification(email: str, is_verified: bool) -> bool:
    """Update the verification status for a user identified by email."""
    try:
        users_table.update_item(
            Key={'email': email},
            UpdateExpression="SET is_verified = :v",
            ExpressionAttributeValues={':v': is_verified}
        )
        return True
    except ClientError as e:
        logging.error(f"Verification update failed: {e}")
        return False

def update_reset_token(email: str, reset_token: str) -> bool:
    """Update the reset token for the user identified by email."""
    try:
        users_table.update_item(
            Key={'email': email},
            UpdateExpression="SET reset_token = :t",
            ExpressionAttributeValues={":t": reset_token}
        )
        return True
    except ClientError as e:
        logging.error(f"Reset token update failed: {e}")
        return False

def update_user_password_by_email(email: str, new_password: str) -> bool:
    """Update the user's password (hashed) and clear the reset token."""
    try:
        hashed = hash_password(new_password)
        users_table.update_item(
            Key={'email': email},
            UpdateExpression="SET password = :p, reset_token = :empty",
            ExpressionAttributeValues={":p": hashed, ":empty": ""}
        )
        return True
    except ClientError as e:
        logging.error(f"Password update failed: {e}")
        return False

def update_user_profile(email: str, profile_data: dict) -> bool:
    """Update the user's profile with the provided profile_data dictionary."""
    try:
        update_expression = "SET " + ", ".join([f"{key} = :{key}" for key in profile_data])
        values = {f":{key}": value for key, value in profile_data.items()}
        users_table.update_item(
            Key={'email': email},
            UpdateExpression=update_expression,
            ExpressionAttributeValues=values
        )
        logging.debug(f"Profile updated for {email} with {profile_data}")
        return True
    except ClientError as e:
        logging.error(f"Profile update failed: {e}")
        return False

def create_post_in_db(post_data: dict, user_id: str) -> Optional[str]:
    """
    Create a new post in the Posts table.
    
    The post_data should be a plain dictionary generated by calling .dict() on your Pydantic model
    (e.g. either a GamingPost or an AnimePost instance).
    """
    post_id = str(uuid.uuid4())  # Generate a unique post ID
    post_data.update({
        'post_id': post_id,              # Add the generated post ID
        'user_id': user_id,              # Associate the post with the user
        'created_at': str(datetime.utcnow())  # Timestamp
    })
    try:
        posts_table.put_item(Item=post_data)
        logging.debug(f"Created post: {post_data}")
        return post_id
    except ClientError as e:
        logging.error(f"Create post failed: {e}")
        return None

def get_post_from_db(post_id: str) -> Optional[dict]:
    """Retrieve a post by post_id from the Posts table."""
    try:
        response = posts_table.get_item(Key={'post_id': post_id})
        return response.get('Item')
    except ClientError as e:
        logging.error(f"Get post failed: {e}")
        return None

def get_posts_by_user(user_id: str) -> List[dict]:
    """Retrieve all posts by a specific user using a GSI on user_id."""
    try:
        response = posts_table.query(
            IndexName="user_id-index",
            KeyConditionExpression=Key('user_id').eq(user_id)
        )
        return response.get('Items', [])
    except ClientError as e:
        logging.error(f"Get posts by user failed: {e}")
        return []

def get_all_posts_from_db() -> List[dict]:
    """Retrieve all posts from the Posts table."""
    try:
        response = posts_table.scan()
        logging.debug("Scanned posts table successfully.")
        return response.get('Items', [])
    except ClientError as e:
        logging.error(f"Error scanning posts table: {e}")
        return []

def filter_posts_from_db(tab: str, main: str, subs: list) -> List[dict]:
    """
    Filter posts by the main genre and subtypes (tags). This function assumes that posts have an attribute 'tags'.
    """
    try:
        filter_expr = None
        
        if main and main.lower() != "null":
            filter_expr = Attr('tags').contains(main)
        
        if subs and len(subs) > 0:
            sub_filter = None
            for sub in subs:
                if sub_filter:
                    sub_filter = sub_filter | Attr('tags').contains(sub)
                else:
                    sub_filter = Attr('tags').contains(sub)
            if filter_expr:
                filter_expr = filter_expr & sub_filter
            else:
                filter_expr = sub_filter
        
        if filter_expr:
            response = posts_table.scan(FilterExpression=filter_expr)
        else:
            response = posts_table.scan()

        logging.debug("Filtered posts fetched successfully.")
        return response.get('Items', [])
    except ClientError as e:
        logging.error(f"Error filtering posts: {e}")
        return []

def get_event_from_db(event_id: str) -> Optional[dict]:
    """Retrieve an event by event_id from the Events table."""
    try:
        response = events_table.get_item(Key={'event_id': event_id})
        return response.get('Item')
    except ClientError as e:
        logging.error(f"Get event failed: {e}")
        return None

def register_user_for_event(user_id: str, post_id: str) -> bool:
    """Add a user to the list of registered users for a given event/post."""
    try:
        events_table.update_item(
            Key={'event_id': post_id},
            UpdateExpression="SET registered_users = list_append(if_not_exists(registered_users, :empty_list), :val)",
            ExpressionAttributeValues={
                ":val": [user_id],
                ":empty_list": []
            }
        )
        logging.debug(f"User {user_id} registered for event {post_id} successfully.")
        return True
    except ClientError as e:
        logging.error(f"Register for event failed: {e}")
        return False

def update_user_password(user_id: str, new_password: str) -> bool:
    """Update the user's password in the Users table."""
    try:
        hashed = hash_password(new_password)
        users_table.update_item(
            Key={'user_id': user_id},
            UpdateExpression="SET password = :p",
            ExpressionAttributeValues={":p": hashed}
        )
        logging.debug(f"Password updated for user: {user_id}")
        return True
    except ClientError as e:
        logging.error(f"Password update failed for user {user_id}: {e}")
        return False
